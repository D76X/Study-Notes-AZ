# AZ-203-04-01

## [Develop Azure Platform as Service Compute Solutions (20-25%)](https://www.microsoft.com/en-us/learning/exam-az-203.aspx)

Implement authentication

- implement authentication by using certificates, forms-based authentication, or tokens
- implement multi-factor or Windows authentication by using Azure AD
- implement OAuth2 authentication
- implement Managed Service Identity (MSI)/Service Principal authentication 

---

### Main Resources  

1. [Microsoft Azure Authentication Scenarios for Developers by Sahil Malik](https://app.pluralsight.com/library/courses/microsoft-azure-authentication-scenarios-developers/table-of-contents) 

2. [Azure AD for Developers](https://app.pluralsight.com/library/courses/azure-active-directory-developers/table-of-contents)  

3. [Design Authentication for Microsoft Azure by John Savill](https://app.pluralsight.com/library/courses/microsoft-azure-authentication-design/table-of-contents)  

4. [Managing Microsoft Azure Information Protection by Ned Bellavance](https://app.pluralsight.com/library/courses/microsoft-azure-information-protection-managing/table-of-contents)  

5. [Managing Microsoft Azure Subscriptions by Daniel Lachance](https://app.pluralsight.com/library/courses/microsoft-azure-subscriptions-managing/table-of-contents)    

6. [Implementing Managed Identities for Microsoft Azure Resources by Manoj Nair](https://app.pluralsight.com/library/courses/microsoft-azure-resources-managed-identities-implementing/table-of-contents) 

7. [Implementing and Managing Azure Multi-factor Authentication by Neil Morrissey](https://app.pluralsight.com/library/courses/azure-multi-factor-authentication-implementing-managing/table-of-contents)  

8. [Managing Identities in Microsoft Azure Active Directory by Ned Bellavance](https://app.pluralsight.com/library/courses/microsoft-azure-active-directory-managing-identities/table-of-contents)

9. [Microsoft Hybrid Identity - Overview by Gary Grudzinskas](https://app.pluralsight.com/library/courses/microsoft-hybrid-identity-overview/table-of-contents)   

10. [Implementing Microsoft Azure Privileged Identity Management by Ammar Hasayen](https://app.pluralsight.com/library/courses/microsoft-azure-privileged-identity-management-implementing/table-of-contents)  

### Related Resources  

1. [Managing Microsoft Azure App Service Protection by Benjamin Culbertson](https://app.pluralsight.com/library/courses/microsoft-azure-app-service-protection-managing/table-of-contents)  

2. [Securing Virtual Machines with Azure Key Vault by Gary Grudzinskas](https://app.pluralsight.com/library/courses/securing-virtual-machines-azure-key-vault/table-of-contents)   

3. [Using Microsoft Azure Resource Groups by Gary Grudzinskas](https://app.pluralsight.com/library/courses/microsoft-azure-resource-groups-using/table-of-contents)  

4. [Managing Microsoft Azure Subscriptions by Dan Lachance](https://app.pluralsight.com/library/courses/microsoft-azure-subscriptions-managing/table-of-contents)   

### Supplementary Resources  

1. [How SAML, OAUTH, and other Identity Federation Solutions Work in a Windows Enterprise](https://www.youtube.com/watch?v=GJyyVjzQ4a0)  

2. [Azure AD Federation Fundamentals](https://www.youtube.com/watch?v=8ioiDrjI0Z4)  

3. [Understanding Active Directory Federation Services an Introduction](https://www.youtube.com/watch?v=xwWb7S6OvFI)  

4. [How SSL works tutorial - with HTTPS example](https://www.youtube.com/watch?v=iQsKdtjwtYI)

5. [Breaking Down the TLS Handshake](https://www.youtube.com/watch?v=cuR05y_2Gxc)  

6. [JWT](https://jwt.io/)  
JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties. JWT.IO allows you to decode, verify and generate JWT.

7. [What is Cross Origin Resource Sharing (CORS)?](https://www.codecademy.com/articles/what-is-cors)  

8. [What is ‘CORS’? What is it used for?](https://medium.com/@electra_chong/what-is-cors-what-is-it-used-for-308cafa4df1a)

8. [CORS Enabled](https://www.w3.org/wiki/CORS_Enabled)  

10. [HTML5 Security Part 3/3 - CORS](https://www.youtube.com/watch?v=9_BFGgfAHD8)

11. [OAuth 2.0: An Overview](https://www.youtube.com/watch?v=CPbvxxslDTU)  

12. [What is OAuth2? How does OAuth2 work? | Tech Primers](https://www.youtube.com/watch?v=bzGKgC3N7SY)  

---

### [What is Active Directory Federation Services (ADFS)](https://www.youtube.com/watch?v=xwWb7S6OvFI)  

- AFDS is an **integrated** **claim-based identity management solution**.
- Provides **SSO** for web applications.
- Send **claims** to a web application **on behalf of AD**.
- helps to **support web service interoperability** between vendors.

### The most common authentication mechanics used by ADFS - SAML 2.0

When a request at the URL of a reource or service is received it replies to the request (from the browser) with a **HTTP 302 URL redirection to the URL of the on-premise ADFS server**.

The **on-premise ADFS server**  receives the **authentication request** from the user's browser **for the cloud service or resource** the user tried to access. It then **authenticates** the user against the **on-premise AD Service** and replies to the uthentication request from the user's browser with **a set of claims for the authenticated user and the cloud resource that the user tried to access** all wrapped-up in a **cookie**.

Finally the user brower is redirected by the **ADFS HTTP 302 response** back to the same URL of the cloud resource or service it wanted to access in the first place but this time it is able to present its **identity and the claims for the requested cloud service or resource**.

### Credentials are never exposed to the cloud 

One of **the most important facts** to keep in mind about the mechanics of ADFS is that users who want or need to access resources or services made available in the cloud are **never** requested to provide any credentials to any part of the cloud infrastructure at the time they attempt to consume those services. **Users are authenticated entirely on premise and any username o passoword** inputted by users in their browser are aonly transmitted to the ADFS Server and then relayed to AD and are kept within the confine of the enterprise IT infrastructure.

### Attributes included in the claim

The **claim-based** cookie that is presented to the cloud resource at the end of the authentication process is **agreed in advance** between the cloud service and the ADFS Server. Claims might be a set of information tokes such as **Firstname, Lastname, email adress, department, etc.**. 

---

### [What is Azure AD and why do we need it?](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m1&clip=1&mode=live)    

### [What are the limits of Active Direcory (AD)?](https://app.pluralsight.com/player?course=microsoft-azure-authentication-scenarios-developers&author=sahil-malik&name=81397afd-a564-4afd-826d-07968d4f5e4f&clip=1&mode=live)  

In the **Windows Ecosystem** **Authentication is implemented by means of the long standing Active Directory (AD)**. However, **AD does not scale well** in all cases that involves actors who might need to authenticate from outside the boundaries of the organization.

**Active Directory also represents a single point of failure** as in the case its services may become unavailable the parts of the organization which depends on those services to be available in order to function would not be able to do so. For example users may not be able to access their email inbox or even to log on their PCs or devices.

These cases have become predominant in all sectors of industry. The list below shows a sample of typical user cases in which authentication must be performed for someone who is physically located outside the organization premises.

- Agents, Salespeople, etc. with a **mobile device** who need to access on-premise services.
- Third part contractors who might need to access on-premise resources.
- Individuals who are part of the resident staff of the organization but are allowed to perform **remote working**.

Any of these scenarios has **already** its own solution with traditional techniques which **extend the traditional AD such as Federation or VPN Tunnel or adhoc accounts**. However, in all cases there is **limited flexibility and increase complexity and costs in addition to several technical problems** which mak it hard to set-up, configure and maintain such solutions.

**Azure AD** has been designed from the ground up to adress also these problems among others whic are appened in the list below.

### [Problems with AD](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m1&clip=1&mode=live)  

- Authentications scenarios have gone beyond the simple case of the on-premise user PC with the advent of mobile devices, remote working, cloud services.
- AD represent a **single point of failure** whithin the organization i.e. if the AD controller went down then there would not be any email, Outlook, Sharepoint, etc.
- On-premise Active Directory is **not designed for Internet scale** above all because the main design is based on a hierarchy of trust that does not traslate at all to the reality of cloud services and intergation with third-party services and APIs.
- The **amount of information exchanged** for the purpose of authentication between the user's PC and the AD Controller **is large and the process is repeated several times**. In fact **any time** a resource under a **AD Domain Controller** is accessed the operation requires a new authentication exhange which may be possible in the scenario of on-premise private network but it cannot scale to the Internet in the scenario of distributed services.While this is OK with the on-premise infrastructure it is not suitable for authentication protocols that must take place over the Internet (public infrastructure). 

### [How Azure AD solves these problems](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m1&clip=1&mode=live)  

- Azure AD is designed from the ground up to provide **Authentication Services** **built on standard protocols already in use over the Internet (OAuth1/2, SAML. PKCE, WS-Federation, etc.)** and therefore able to scale in those scenarios.

---

The following table illustrates the corrispondence betwenn traditional AD technologies and some of the solution that allow to achieve the same result but are independent of AD and are therefore more scalable.


| AD                      | Open Solutions             |
| ----------------------- | -------------------------- |
| `Group Policies`  | Mobile Device Management (MDM) |  
| `Kerbeors/NTML`   | OpenID & OAuth |
| `Session Based Security` | Acess Tokens & Refresh Tokens |

---

## [Azure AD](https://app.pluralsight.com/player?course=microsoft-azure-authentication-scenarios-developers&author=sahil-malik&name=81397afd-a564-4afd-826d-07968d4f5e4f&clip=2&mode=live)   

[**Azure AD** is an **entirely new** product that is **independent of AD**, although it can easily work together with AD.](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m1&clip=1&mode=live)  

- It is suitable for the cloud.
- Supports modern Authentication Protocols i.e. **[OpenID & OAuth](https://www.youtube.com/watch?v=GyCL8AJUhww)**.
- Provides **SDKs for almost any platform**.
- Supports **B2C, B2B and B2E** authentication.
- There are numerous SaaS Applications that integrate with Azure AD already available on teh marketplace.
- It is **completely free** for any organization to use as the **defacto standard for Authorization**, officially with a limit of 500.000 users which can be lifted, for free, if necessary.
- it is the **Authentication mechanism usedby Office 365** and therefore already in place in most organizations.

---

### [Azure AD Connect](https://app.pluralsight.com/player?course=microsoft-azure-authentication-scenarios-developers&author=sahil-malik&name=81397afd-a564-4afd-826d-07968d4f5e4f&clip=2&mode=live)  

[Azure AD Connect](https://www.microsoft.com/en-us/download/details.aspx?id=47594) is a tool that allows organization to easily migrate from their on-premise AD to Azure AD. There are essentially two ways in which such migration can be [achieved](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m1&clip=2&mode=live) .

1. AD identities and the Authentication service are both migrated to the cloud. 

2. The AD identiites are migrated to Azure AD but the authentication service remains on premise and AD Azure Authentication **federates the authentication to the on premise AD Authentication Service (ADFS)**.

When the migration strategy is to transfer the AD credential to Azure AD then the **Azure AD Connect** tool can do so by passing the hash of the password stored in AD on-premise directly as it is or as a new hash of this hash. In the latter case AD Azure remains oblivion of the original hash and merely provides Authentication Services on behalf of the on-premise AD Controller.

---

## [Authentication Scenarios](https://app.pluralsight.com/player?course=microsoft-azure-authentication-scenarios-developers&author=sahil-malik&name=81397afd-a564-4afd-826d-07968d4f5e4f&clip=4&mode=live)  

- Form-based Authentication
- Business to Consumer (B2C) Authentication
- Token-based Authentication to SQL
- Multi-Factor Authentication (MFA)
- Certificate-based Authentication

---

## [Form-based Authentication](https://app.pluralsight.com/player?course=microsoft-azure-authentication-scenarios-developers&author=sahil-malik&name=1588d422-3e09-4635-96cc-353b5e6bca48&clip=0&mode=live)  

This scenario is the simple case in which a user needs to authenticate to a service through a web form by providing their own AD credentials.

[Form-based Authentication can in general be achieved by one of the following mecanisms.](https://app.pluralsight.com/player?course=microsoft-azure-authentication-scenarios-developers&author=sahil-malik&name=1588d422-3e09-4635-96cc-353b5e6bca48&clip=1&mode=live)  

### [Impotant Protocols](https://app.pluralsight.com/player?course=microsoft-azure-authentication-scenarios-developers&author=sahil-malik&name=1588d422-3e09-4635-96cc-353b5e6bca48&clip=2&mode=live)  

1. WS-Federation
2. SAMLP - Security Assertion Markup Language Protocol
3. OpenID Connect 
4. OAuth2 Implicit Flow - suitable for SPAs
5. Authorization Code Grant Flow - suitable for Native Apps
6. Proof of Key Exchange (PKCE) flow - suitable for mobile apps

---

## Protocols bit by bit 

### 1. [The various flavour of **Federation & Claim-based Architecture**](https://www.youtube.com/watch?v=GJyyVjzQ4a0) [24:00]

### 2. [SAML vs AOuth](https://www.youtube.com/watch?v=GJyyVjzQ4a0) [30:00]

| SAML                      | OAuth                    |
| ------------------------- | ------------------------ |
| mostly for **SSO**        | mostly used for APIs |
| mostly browser            | browser and native apps |
| heavyweight digitally signed large XML | small JSON random token |
| mostly browser            | browser and native apps |
| expensive validation | simple validation|
| many security options | few security options |


### 3. [Kerbeors/NTML](https://www.youtube.com/watch?v=GJyyVjzQ4a0) [38:49]

---

## [Authentication Scenarios](https://app.pluralsight.com/player?course=microsoft-azure-authentication-scenarios-developers&author=sahil-malik&name=1588d422-3e09-4635-96cc-353b5e6bca48&clip=3&mode=live) 

The following are all typical Authentication scenarios and for each specific pattern, tools and practices are routinely employed in the IT industry. An in-deapth examinations of all of these scenarios is avalable in the course [Azure AD for Developers](https://app.pluralsight.com/library/courses/azure-active-directory-developers/table-of-contents). In the demos available in this course the author makes use of the [Azure AD Authentication Library (ADAL)](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m1&clip=3&mode=live)
for the various platforms implied in the following authentication typical scenarios. 

- [Web Browser to Web App](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m2&clip=1&mode=live)
- [SPA to WebApi](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m3&clip=1&mode=live) - **must enable OAuth2 Implicit Grant Protocol**
- [Native Apps to Azure AD Secured Resources](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m5&clip=0&mode=live)
- WebApp to WebApi under user credentials
- WebApp to WebApi using the App Identity
- [Deamon/Background Process](https://en.wikipedia.org/wiki/Daemon_(computing)) to WebApi   

It is useful to briefly expand on these scenarios which is done below. Moreover, it is important to remeber that all these authentication sceanrios **have their own authentication flow** which is what characterises each one. It is therefore advisable to memorise the flow of each.  

---

### [Web Browser to Web App](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m2&clip=0&mode=live)    
This is the simple case of a user that from their web brower visits a page of a web site which requires the user to be authenticated in order to access the resource. For example, in the ASP.Net realm this would be the EP of a controller on which the [Authorize] attribute is applied. When **Azure AD** is used as **authentication provider** the
**web site** must be registered with Azure AD and must hold in its configuration the **authentication URL to which the user browser must be redirected to in order to authenticate**. 

#### [Web Browser to Web App Flow](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m2&clip=1&mode=live)     

1. With a web browser you visit the page of the site that requires authorization.
2. The web site cannot find the autorization token in the header of the request and **redirects (HTTP 302)** the browser to an **Azure AD endpoint registered for the web site and the Client App ID that is to be presented to Azure AD**.
3. **Azure AD** responds to the browser request with a login page.
4. The user provides their credentials that are transimmted to **Azure AD over SSL together with the Client App ID**.
5. **Azure AD** uses the credential to authenticate the user or to **delegate to another authentication parties i.e. a registered AFDS or third-party authenticaution server**.
6. If the client is authenticated then **Azure AD** returns to them **authentication token** in the header of the reply and redirects them to the original URL that the browser tried to access and has obtained a authentication token for. This token is embedded in the header of the new request made for this resource.
7. The web site receives the new request and this time finds the authentication token which the internal authentication logic of the server can use to verify that it actually comes from the the **Azure AD endpoint with which the site is registered and that is a valid token**.
8. The side returns to the browser a **session cookie** that will be used for the duration of the user session
9. Finally, the user can begin to **issue authenticated requests to the site for the duration of the session**. The duration of the session depends on the expiration set in the session cookie provided by the web app. 
10. On the expiration of the session the user will have to repeat the authentication.

### Important Notes

This is a **cookie based authentication flow** and it has nothing to do with any of the OAuth flows for authorization. There is no delegation to third-party resources access and all that happens in this scenario is tha the web backend trusts Azure AD that the user is known and allowed to use the application. **There is no authorization** implied in this mechanism and therefore the web backend still needs to employ some other mechanism to decide which resources this authenticated users is allowed to access. 

---

#### [Brief Summary on Cross Origin Resource Sharing (CORS)](https://www.codecademy.com/articles/what-is-cors)   

### WHY IS CORS NECESSARY?

The CORS standard is needed because it allows servers to specify not just **who** can access its assets, but also **how** the assets can be accessed. With CORS, a server can specify **who** can access its assets and **which HTTP** request methods are allowed from external resources.

Most servers will allow GET requests, meaning they will allow resources from external origins (say, a web page) to read their assets. HTTP requests methods like PATCH, PUT, or DELETE, however, may be denied to prevent malicious behavior.

### HOW DOES CORS MANAGE REQUESTS FROM EXTERNAL RESOURCES?

An HTTP header is a piece of information associated with a request or a response passed back and forth between your web browser (cleint) and a server. The CORS standard manages cross-origin requests by adding **CORS HTTP headers** to the standard list of headers. 

- Access-Control-Allow-Origin
- Access-Control-Allow-Credentials
- Access-Control-Allow-Headers
- Access-Control-Allow-Methods
- Access-Control-Expose-Headers
- Access-Control-Max-Age
- Access-Control-Request-Headers
- Access-Control-Request-Method
- Origin

#### Access-Control-Allow-Origin

The **Access-Control-Allow-Origin** header allows **servers** to specify how their resources are shared with external domains. CORS allows servers to specify certain trusted ‘origins’ they are willing to permit requests from. 

Origins are defined as the combination of protocol (http or https), host (a domain like www.example.com or an IP address) and port. 

To instruct the browser to expose server responses to a HTTP requests from certain origin, the web server **must** respond to the request with an additional HTTP response header, ‘Access-Control-Allow-Origin: <origin>’. 

When a GET request is made to access a resource on Server A, Server A will respond with a value for the Access-Control-Allow-Origin header. Many times, this value will be *, meaning that Server A will share the requested resources with any domain on the Internet. Other times, the value of this header may be set to a particular domain (or list of domains), meaning that Server A will share its resources with that specific domain (or list of domains).

#### PRE-FLIGHT REQUESTS  

As mentioned before, most servers will allow GET requests but may block requests to modify resources on the server. Servers don’t just blindly block such requests though; they have a process in place that first checks and then communicates to the client (your web browser) which requests are allowed.

The preflight request is an OPTIONS request made to the same HTTP path as the actual request, with a couple of HTTP headers.

- `Origin` — The origin header that would be included with the actual request being made by the website.
- `Access-Control-Request-Method` — The method of the actual request being made by the website.
- `Access-Control-Request-Headers` — A comma-separated list of headers that would be included in the actual request.

Web servers that wish to support CORS requests must respond to preflight requests with the following HTTP headers:

- `Access-Control-Allow-Origin` — The whitelisted origin, or ‘*’
- `Access-Control-Allow-Methods` — A comma-separated list of HTTP methods the web server wishes to permit for cross-origin requests
- `Access-Control-Allow-Headers` — A comma-separated list of HTTP headers the web server wishes to permit for cross-origin requests

If any of the information in the response headers does not match the actual parameters of the request, the browser will not send the actual request.

When a request is made using any of the following HTTP request methods,a standard preflight request will be made before the original request.
Preflight requests use the OPTIONS header. The preflight request is sent before the original request, hence the term “preflight.” The purpose of the preflight request is to determine whether or not the original request is safe (for example, a DELETE request). The server will respond to the preflight request and indicate whether or not the original request is safe. If the server specifies that the original request is safe, it will allow the original request. Otherwise, it will block the original request.

- PUT
- DELETE
- CONNECT
- OPTIONS
- TRACE
- PATCH

#### [WHY HAVE CORS and SOP BEEN INTRODUCED?](https://medium.com/@electra_chong/what-is-cors-what-is-it-used-for-308cafa4df1a)  

**The Cross-Origin Resource Sharing** policy was introduce to **prevent cross-site request forgery (CSRF or XSRF)**.

Before browsers implemented **Single Origin Policy (SOP)**, malicious websites were able to exploit cookies stored by your browser to make unauthorized requests to other domains. Some of these unauthorized requests could do things like make purchases, delete user information, fetch sensitive data, etc. As an example, you might go to a banking website and provide some credentials to log into your account. Your username is stored in a secure browser cookie for a certain period of time so the bank can tell you are still logged in instead of having you login another time with each page you access. Later on, you go to an innocent-seeming webpage listing some facts about bunnies. Unbeknownst to you, the webpage’s HTML also has a little Javascript script to make an AJAX request (see: XMLHttpRequest) to the previous banking website to make a wire transaction to another account. Because your session is still authenticated with the cookie that was stored earlier, the banking website thinks it’s just you clicking on a link on their site to submit a wire transaction. The easy fix was for browsers to detect when a request is made from one website to another and prevent the response from being readable. This is the Same-Origin Policy.

---

### [SPA to WebApi](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m3&clip=0&mode=live)  

This is a very typical scenario in modern WebApps. Some JavaScript (or other language) for example a SPA or just some JavaScript embedded in a web app or native app or similar makes calls to a WebApi in order to retrieve information. 

**In these cases the caller plays the role of a native application** and it is **required that both the calling application and the WebApi are registered with Azure AD**.

Further, in Azure AD **the calling application must be whitelisted for the WebApi** in order for the authentication flow to be performed correctly. 

One important detail is that both sides that is the native calling application and the WebAPi must hold some kind of **config.json** some details about their registration with Azure AD and **must also explicitely enable OAuth2 Implicit Grant Protocol, which is disabled by default,** in order for this authentication flow to work. 

Lastly, in case the calling app is a WebApp that is some JavaScript executing in a page of a browser or downloaded from some web site then **CORS may also play a part** as the web page in which the calling JavaScript is embedded might have come from a **domain that is not the domain of the WebApi that it makes calls to**. This is forbidden by default according the **Single Origin Policy (SOP)** by any browser and must be **explicitely authorized in the web application**.
Referer to the notes on SOP & CORS for more information on this topic.  

### [SPA to WebApi Flow - AOuth2 Implicit Grant Protocol](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m3&clip=1&mode=live)   

1. Download the native app from some domain or get it istalled on the user system. This native app is designed to make calls to a WebApi on a different domain (or same domain is some simpler cases) it has been downloaded from.

2. The native app is registered in Azure ID and an **Azure_AD_App_ID** provided by Azure AD the application to the directory. The application needs to store this ID i.e. in its config file or hard coded.

3. If the native application runs in a browser and it has been downloaded from a domain different from that of the WebApis that it needs to make calls then **CORS must be enabled on the servers of the WebApis in order to allow the HTTP calls from the domain of the page in which the native application runs**. For the web application in order to be able to read the resource that it gets from the WebApi the response from the WebApi must have a `Access-Control-Allow-Origin` header whose value is eiether `*` or `a list of domains that includes the domain the calling application comes from`. [This Demo](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m4&clip=3&mode=live) shows how to enable CORS for a WebApi built with ASP.Net and for teh case `Access-Control-Allow-Origin: *`. 

```
 Access-Control-Allow-Origin: *
 Access-Control-Allow-Origin: http://someapi1.com, http://someapi2.com 
```

4. At this point once CORS is enabled on the WebApi Server the native application could make at least a GET calls to the WebApi and be able to read the responses. However, because the WebApi require authorization **before** the calls to the WebApis are made the native application **must** go through authentication and authorization and **obtain the necessary tokens**. Therefore the native application **first** go to the **Azure AD End Point** and presents its **APP_ID and the App Client ID of the WebApis that it needs access to** so that **Azure ID DIrectory** can produce the authentication tokens it needs once the user of the app provides valid user credential to Azure ID during teh sign-in. 

It is **paramount** that you see the **difference between this workflow and the previous one (Web Browser to WebApp)** as in this one there is no HTTP 302 redirect tha is there is  no challenge. Clearly the native app must hold in its configuration at least the **its Azure AD APP_IP and the Client App ID of all the WebApis that it needs to call**. However it **doesn not** need to store the URLs of the WebAppis to call as those are provided as URL redirect after authentication on Azure AD.

5. The WebAppis that the native application calls are also registered with **Azure ID** and for each WebApi **Azure AD holds a list of allowed APP_IDs** for which **authorization tokes will be granted**. 

6. **Azure AD** responds to the native application with a **HTTP 202 redirect over SSL only to a preregistered reply URL**. **This is a very important security feature as only the owner of the domain of the SPA which has been previously registered with Azure AD is going to e able to acquire the access token provided by Azure AD after sign in**. A malicious user may as well know the SPA Clint ID but cannot own the registered domain. The **URI fragment** of the response contains the **JWT Authentication Token with the access claims aka ID Token and the URL of the WebApi**. The response is on **SSL** to prevent the token to be tapped in and stolen which would make it possible for attackers to steal the access token and target the WebApi for the duration of the token. The other fragment parameter is the **WebApi URL** which is one of a set of URLs that the owner of the WebApi has provided to **Azure AD** when the WebApi is registered with the directory service. **Azure AD has Implicit Grant Flow disabled by default. In order for this flow to work with Azure AD it must be explicitely re-enabled**.

7. The JavaScript app (SPA) can now make calls to the WebApi at the provided URL normally over **SSL** and in the header of the calls it includes the **JWT Authentication Token ID (access token)** for the WebApi.

8. The WebApi reads the request and the **JWT Authentication Token ID it verifies it against Azure AD** and if all is OK and the access token is not yet expired it satifies the request by either retuning a resource or executing the request with the corresponding HTTP verb.  

### [ADAL and support to reobtain a new access token silently](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m3&clip=4&mode=live)    

The whole process is to be repeated every time the access token expires. Unfortunately, this can be a great usability problem as in order to be secure the access token obtain in the Implicit Grant Flow shoul be set to be short lived i.e. 300 secs that as a few minutes. The problem is that the SPA would soon become difficult to use if the user had to sign in to Azure AD every few minutes in order to acquire a new access token for each of the WebApp the SAP makes use of.

However, this is a problem with no easy solution because to keep the flow secure the access token must be set with a short expiration otherwise an attacker that managed to gain access to it from teh insecure SPA would be able to impersonate the user of the application for the duration of the access token at great risk. 

[The ADAL library for JavaScript](https://github.com/AzureAD/azure-activedirectory-library-for-js)  offers a mechanism to reobntain a new access token from Azure AD before the expiration of the one currently in use. This mechanism **relies on an invisible iFrame and a authentication cookie from Azure AD**. This works for all the WebApi tha the SPA needs acces too and that are registered with Azure AD and for which the SPA is a registered consumer. 

---

### [OAuth 2.0](https://www.youtube.com/watch?v=CPbvxxslDTU)  

Modern WebApi almost always employ the authentication scheme Auth 2.0 which is why it is discussed more in depth here. OAuth is an **open standard (protocol)** that has been designed to achieve two goals.

1. Authentication
2. Acess Delegation

It is useful to visit the following resources to brush up on what OAuth 2.0 is and how its workflow works and its most common user cases.

- [OAuth 2.0: An Overview](https://www.youtube.com/watch?v=CPbvxxslDTU)
- [What is OAuth2? How does OAuth2 work? | Tech Primers](https://www.youtube.com/watch?v=bzGKgC3N7SY)  
- [OpenID Connect FAQ and Q&As](https://openid.net/connect/faq/) 
- [An Introduction To OpenID Connect](https://www.youtube.com/watch?v=6DxRTJN1Ffo)  


#### The Roles in OAuth 2.0 open protocol

- User
- Application i.e. Spotify, a Banking App, etc.
- The Api i.e. Facebook, Twitter, Google, or a proprietary Api etc.

The **Api** is further split into the following two servers

- Authentication Server
- Resource Server

#### The OAuth 2.0 Workflows

OAuth 2 really encompasses two parts

1. Authorization
2. Authentication - this is [**OpenID Connect**]((https://openid.net/connect/faq/))
  
---

### The thre parts if OAuth 2 parts - Registration, Authentication, Authorization.

1. Registration 
2. Authentication 
3. Authorization.



---

#### Registration of the Application wih the Api (Authorization Server)

In the following the **OAuth 2 authorization workflow** is detailed. However, in order for it to work the **application** must first be registered with the **Authorization Server**. 

The **Application** must provide the **Authorization Server** with the following details.

- The name of the application.
- The URL (domain) of the web site of the application.
- The URL to which the user will be redirected to after the user leaves the **Authorization Screen** to which the **Authorization Server** has sent them to in the case the user has authorized teh application to access the details about the user on the **Resource Server** that the **application** needs.

After the **registration of teh application with the Authorization Server** is performed the **Autorization Server** produces the following.

1. **CliendID** for the registred application to **unquely** indentify the application with the **Authorization Server**.
2. **Client Secret** that is **private** identifier shared by the application and the Api. This is used to **authenticate** the **application** when it requests the **Authorization Server** for an **Acess Token** in the **Authorization Workflow**.

---

#### Grant Types

1. Authorization Code Grant Type
2. Implicint Grant
3. Password Grant
4. Client Credential Grant

The **Authorization Code Grant** is the grant returned to an application that runs on a web server. In this case it is the web server where the application runs that issues an **authorization request** to the **Authorization Server**.

The **Implicit Grant** is the grant that is retuned to an application that runs in a web browser. We have seen this grant the case of a SPA that calls a WebApi.

The **Password Grant**..

The **Client Credential Grant**..

---

#### The OAuth 2.0 Authorization Workflow

1. The **User** tries to access a resource provided by the 
**application** which requires some interaction with the **resource server** fro example to retrieve from it account details.

2. The **Application** issues a request to the **Authorization Server** and the **Authorization Server** responds to this request with a **HTTP page (the Authorization Screen)** that shows to the **User** a dialog where they are notified that the **Application** requires **authorization** to access reources from the **Resource Server** and lists the resources that the application needs to access like in the simple example below.

```
Do you whish to authorize the App : My Banking Co
to acess : Your account info and transaction history
?
Yes - No
```

3. The **User** might **deny or grant** permission to the **application** to **access** the required information from the **Resource Server**.

4. If the **User** allows the application to access the reources then the **Authorization Server** issues an **Authorization Grant** and **Authorization Token** to the **Application** and add them in its response to its initial request.

5. The **Application** presents the **Authorization Grant & Token** to the **Authorization Server** in a new request to ask the **Authentication Server** to **Authenticate the application with the Resource Server** so that it will then be able to access the resources it needs.

6. As the **Authentication Server** receives the requests from the **Application** to **authorize** it to the **Resource Server** the **Authentication Server** reads the **Grant & Token** from the reuest and produces a **Acess Token** for the **resources that the application needs to access on the Resource Server**. It returns this **Acess Token** to the caller in its response. Howver in OAuth 2.0 there are both the **Acess Token and the Refresh Token**.

7. The **Apllication** now sends the request to the **Resource Server** with the **Acess Token**. 

8. The **Resource Server** validates the **Acess Token** and returns the **protected resources** that have been requested to the **application** in its response.

#### [Acess Delegation](https://www.youtube.com/watch?v=bzGKgC3N7SY)  



**Acess Delegation** is the mechanism by which a party on the Internet i.e. a WebApi or website **delegates to an external authorization party** the resposibility of producing the claims for a caller. 

The typical scenario is that of a web application which provides services to their users. However, rather than holding user credentials the site allows its users to make use of the accounts they already have with other authorities such as Google or Facebook. 

Therefore, when users try to make use of **the web application this will ask the user whether they wish to**

 their account on the web site OAuth delegates the authentication to Google or Facebook which return teh claim the user has for the web site they are trying to access. The web site does no longer hold any authentication data related to teh user thus its free from thsi responsibility. 

 The autherntication scheme OAuth 2.0 improves upon the authentication scheme OAuth 1.0 in that it defines **two authentication tokens**.

- Access Token
- Refresh Token

| Access Token              | Refresh Token            |
| ------------------------- | ------------------------ |
| goes in the request header| used to get a new access token |
| it is short lived         | it isi long lived        |
|||
|||

An access token is included in the header of any request to a WebApi which demands the caller to be authenticated in order to access the resources it exposes. However, the access token is a liability as if stolen it grants access to a potential attacker. Therefore, traditionally access token have a short expiration to limit teh likelyhodd to be exploited by malicious callers were they stolen i.e. expiration that range from few minutes to an hour are common.

Howver, when the access token expires the caller is forced to re-authenticate which might not be practical for the user 

---

#### [Native Apps to Azure AD Secured Resources](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m5&clip=0&mode=live)

---

#### WebApp to WebApi under user credentials
#### WebApp to WebApi using the App Identity
#### Deamon/Background Process to WebApi

---

## [ADAL - Azure AD Authentication Library](https://app.pluralsight.com/player?course=azure-active-directory-developers&author=sahil-malik&name=azure-active-directory-developers-m1&clip=3&mode=live)  

ADAL is an open source library maintained by Microsoft.

All the aspects of Azure AD, the traditional AD and ADFS that ahev been discussed so far demonstrate how complex the theme of modern Authentication can be. 

There are typically two sides to take into account.

1. The processes and practices that must be implemented by the IT department to set up AD, ADFS and Azure AD according to the specific requirement of their organization.

2. The knowledge which developer must attain and maintain in order to make sure that the applications, APIs, web and cloud services they develop can properly authenticate by means of Azure AD.

While **the former is strictly dependent on the requirement imposed by the specific organization that intends to make use of Azure AD**, the latter is completely disjoint form such knowledge.

Developer of applications, APIs, web and cloud services or apps do not need to know anything about how the Azure AD Service they must make use of in order to authenticate has been set up in order to do so.

However, on the developer's side the complexity lies in the **multitude of available protocols in which authentication can be carried out between parties and Azure AD**. Such complexity can be appreciated by considering **the cross product between the available protocols and the type of parties**.

This has been already described in above but it is repeated below for 
convenience.

### Typical Authentication Scenarios 

- Web Browser to Web App
- SPA to WebApi
- Native Apps to WebApi
- WebApp to WebApi under user credentials
- WebApp to WebApi using the App Identity
- [Deamon/Background Process](https://en.wikipedia.org/wiki/Daemon_(computing)) to WebApi   

### Typical Authentication Technologies

1. WS-Federation
2. SAMLP - Security Assertion Markup Language Protocol
3. OpenID Connect 
4. OAuth2 Implicit Flow - suitable for SPAs
5. Authorization Code Grant Flow - suitable for Native Apps
6. Proof of Key Exchange (PKCE) flow - suitable for mobile apps

---

[ADAL - Azure AD Authentication Library](https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-authentication-libraries)  

The Azure Active Directory Authentication Library (ADAL) v1.0 enables application developers to authenticate users to cloud or on-premises Active Directory (AD) and obtain tokens for securing API calls. ADAL makes authentication easier for developers through features such as:

- Configurable token cache that stores access tokens and refresh tokens
- Automatic token refresh when an access token expires and a refresh token is available
- Support for asynchronous method calls

---